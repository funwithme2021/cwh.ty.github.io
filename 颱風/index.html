<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å…¨çƒç†±å¸¶æ°£æ—‹</title>

  <!-- Libs -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js"></script>

  <style>
    :root{
      --bg:#0b0e13; --panel:#121623; --text:#ecf1ff; --muted:#a9b3c7; --border:#2b3250;
      --chip:#1a2040; --chipOn:#20305a; --sidebar-w:520px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",sans-serif}
    #app{display:grid;grid-template-columns:var(--sidebar-w) 1fr;height:100%;transition:grid-template-columns .2s ease;}
    #app.collapsed{grid-template-columns:0 1fr}
    #sidebar{background:var(--panel);border-right:1px solid var(--border);padding:14px;overflow:auto}
    #map{height:100%;width:100%;position:relative}

    h1{font-size:18px;margin:0 0 10px 0;font-weight:800;letter-spacing:.2px}
    .desc{font-size:12px;color:var(--muted);line-height:1.55;margin-bottom:10px}
    .card{background:#0f1424;border:1px solid var(--border);border-radius:12px;padding:10px;margin-bottom:10px}
    .sec{margin:8px 0 8px;font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:1px}
    .file{display:flex;gap:8px;align-items:center;background:var(--chip);border:1px dashed var(--border);padding:10px;border-radius:12px;cursor:pointer;justify-content:center}
    .file input{display:none}
    .file:hover{background:var(--chipOn)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .mode{display:flex;gap:8px;flex-wrap:wrap}
    .chip{font-size:12px;padding:6px 8px;border-radius:20px;background:var(--chip);border:1px solid var(--border);cursor:pointer;user-select:none}
    .chip[data-active="true"]{background:var(--chipOn);border-color:#3a4b86}
    .toggle{display:inline-flex;gap:6px;align-items:center;font-size:13px}
    .toggle input{width:16px;height:16px}
    .sys-list{display:grid;grid-template-columns:1fr auto;gap:8px 6px;align-items:center}
    .sys-name{font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:-1px}
    .btn{background:#2a3a8a;border:1px solid #3a4b9a;color:#e9f2ff;font-size:12px;padding:6px 10px;border-radius:8px;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}

    .legend{
      position:absolute;bottom:14px;left:calc(var(--sidebar-w) + 20px);z-index:900;
      background:rgba(18,22,35,.95);border:1px solid var(--border);border-radius:10px;padding:8px 10px;
      font-size:12px;color:var(--muted);backdrop-filter:blur(6px);display:flex;align-items:center;gap:10px;flex-wrap:wrap;
    }
    .legend .bar{white-space:nowrap}
    .legend .item{margin-right:12px}
    .legend .tools{display:flex;gap:6px}
    .leaflet-popup-pane{z-index:10000!important}
    .leaflet-tooltip-pane{z-index:10001!important}
    .tag24{font-weight:800;font-size:12px;color:#fff;text-shadow:-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000;pointer-events:none;white-space:nowrap}
    .collapse{position:absolute;left:8px;top:8px;z-index:1200}

    /* å·¦å´ï¼šæ™‚é–“Ã—å¼·åº¦åœ– + æ­·å²æ“ä½œ */
    #tsWrap{height:260px;}
    #historyLog{max-height:200px; overflow:auto; font-size:12px; color:#cfe3ff; line-height:1.5; white-space:pre-wrap; background:#0c1224; border:1px solid #334276; border-radius:8px; padding:8px}
    @media (max-width: 900px){ :root{ --sidebar-w: 420px; } }
  </style>
</head>
<body>
  <button class="btn collapse" id="btnCollapse">éš±è—è³‡æ–™æ¬„</button>

  <div id="app">
    <div id="sidebar">
      <h1>å…¨çƒç†±å¸¶æ°£æ—‹</h1>
      <div class="desc">
        æ™‚é–“é¡¯ç¤ºï¼š<b>å°ç£æ™‚é–“ (UTC+8)</b>
      </div>

      <div class="card">
        <div class="sec">ç·šä¸Šè³‡æ–™ï¼ˆDeepMind WeatherLabï¼‰</div>
        <div class="row">
          <label style="font-size:12px;color:#a9b3c7">æ¨¡å‹</label>
          <select id="dmModel">
            <option value="FNV3" selected>FNV3</option>
            <option value="GENC">GENC</option>
            <option value="GRPH">GRPH</option>
          </select>
          <label style="font-size:12px;color:#a9b3c7">å¾ªç’°</label>
          <select id="dmCycle"></select>
        </div>
        <div class="row">
          <button class="btn" id="btnLoadCycle">è¼‰å…¥æ‰€é¸å¾ªç’°</button>
          <button class="btn" id="btnLatest">æœ€æ–°å¯ç”¨</button>
          <!-- æ–°å¢ï¼šé–‹å•Ÿ WeatherLab å®˜æ–¹ç¶²ç«™ -->
          <button class="btn" id="btnOpenWL" title="é–‹å•Ÿ WeatherLab å®˜æ–¹ç¶²ç«™">WeatherLab</button>
        </div>
        <div class="note">è¿‘ 48 å°æ™‚å…±æœ‰ 8 å€‹ UTC å¾ªç’°ï¼ˆ00/06/12/18ï¼‰ã€‚è‹¥æœ€æ–°æœªå®Œå…¨ç™¼å¸ƒï¼Œå¯æ”¹é¸è¼ƒæ—©å¾ªç’°ã€‚âš ï¸ è‹¥é­ CORS æ“‹ä¸‹ï¼Œè«‹æ”¹ç”¨ä¸‹æ–¹ã€ŒåŒ¯å…¥ CSVã€ã€‚</div>
        <div class="desc" id="dmStatus" style="display:none"></div>
      </div>

      <label class="file" id="fileLabel">
        <input type="file" id="csvFiles" accept=".csv" multiple/>
        <span>ğŸ“„ é»æˆ‘åŒ¯å…¥å¤šå€‹ CSV</span>
      </label>

      <div class="card">
        <div class="sec">æ¨¡å¼</div>
        <div class="mode">
          <span class="chip" id="modeTracks" data-active="true">è·¯ç·šåœ–</span>
          <span class="chip" id="modeProb">æ©Ÿç‡åœ–</span>
        </div>
        <div class="desc">æ©Ÿç‡åœ–ï¼šç›´æ¥ä»¥<b>æ‰€æœ‰å¯è¦‹ç³»çµ±</b>çš„<b>ç³»é›†æˆå“¡é»ä½</b>å»ºç«‹ç†±åº¦åœ–ï¼ˆèˆ‡æ™‚é–“ç„¡é—œï¼‰ã€‚</div>
      </div>

      <div class="card">
        <div class="sec">æ±ºå®šæ€§é¡è‰²</div>
        <div class="mode">
          <span class="chip" id="detBlack" data-active="true">é»‘ç·š</span>
          <span class="chip" id="detIntensity">å¼·åº¦ä¸Šè‰²</span>
        </div>
      </div>

      <div class="card">
        <div class="sec">é¡¯ç¤º</div>
        <div class="row">
          <label class="toggle"><input type="checkbox" id="toggleDet" checked>æ±ºå®šæ€§</label>
          <label class="toggle"><input type="checkbox" id="toggleEns" checked>ç³»é›†</label>
          <label class="toggle"><input type="checkbox" id="togglePts" checked>ç¯€é»</label>
          <label class="toggle"><input type="checkbox" id="toggleRadii" checked>é¢¨åœˆï¼ˆåƒ…æ±ºå®šæ€§ï¼‰</label>
        </div>
      </div>

      <div class="card">
        <div class="sec">é¢¨é€Ÿæ›ç®—</div>
        <div class="row">
          <input type="number" id="wsValue" placeholder="æ•¸å€¼" step="0.01" style="width:110px">
          <select id="wsUnit">
            <option value="kt">ç¯€ (kt)</option>
            <option value="ms">å…¬å°º/ç§’ (m/s)</option>
            <option value="kmh">å…¬é‡Œ/æ™‚ (km/h)</option>
          </select>
          <button class="btn" id="wsCalc">æ›ç®—</button>
        </div>
        <div class="desc" id="wsOut"><span class="muted">çµæœï¼š</span>â€”</div>
      </div>

      <div class="card">
        <div class="sec">ç³»çµ±æ¸…å–®ï¼ˆtrack_id | æª”åï¼‰</div>
        <div id="systems" class="sys-list"></div>
      </div>

      <!-- ç§»å…¥å·¦å´ï¼šæ™‚é–“ Ã— å¼·åº¦åœ– -->
      <div class="card">
        <div class="sec">æ™‚é–“ Ã— å¼·åº¦åœ–</div>
        <div class="row" style="margin-bottom:6px">
          <select id="tsSystemSel" style="max-width: 60%"></select>
          <span class="chip" id="tsModeDet" data-active="true">æ±ºå®šæ€§</span>
          <span class="chip" id="tsModeEns">æ‰€æœ‰ç³»é›†</span>
        </div>
        <div id="tsWrap"><canvas id="tsChart"></canvas></div>
        <div class="desc">èªªæ˜ï¼šæŠ˜ç·šå›ºå®šè‰²ã€æ¯å€‹<strong>é»</strong>ä¾å¼·åº¦ä¸Šè‰²ï¼›æ»‘é¼ ç§»å…¥é¡¯ç¤ºè©³ç´°è³‡è¨Šèˆ‡åˆ†ç´šã€‚</div>
      </div>

      <!-- ç§»å…¥å·¦å´ï¼šæ­·å²æ“ä½œèˆ‡è¨ºæ–· -->
      <div class="card">
        <div class="sec">æ­·å²æ“ä½œèˆ‡è¨ºæ–·</div>
        <div id="historyLog"></div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <!-- æµ®å‹•å·¥å…·åˆ—ï¼ˆå–®ä½åˆ‡æ›ï¼‹åˆ†äº«ï¼‰ -->
  <div class="legend" id="legend">
    <div class="bar" id="legendText"></div>
    <div class="tools">
      <button class="btn" id="unitToggle" title="åˆ‡æ›å–®ä½">å–®ä½ï¼škt</button>
      <button class="btn" id="btnShare" title="ç”¢ç”Ÿå¯åˆ†äº«é€£çµ">åˆ†äº«æ­¤è¦–åœ–</button>
    </div>
  </div>

  <div class="toast" id="toast">å·²è¤‡è£½é€£çµï¼</div>

  <script>
    // ====== åŸºæœ¬ç‹€æ…‹ ======
    let preferredUnit = 'kt'; // 'kt' | 'ms' | 'kmh'
    const KT_TO_MS = 0.514444, KT_TO_KMH = 1.852;
    const tz = 'Asia/Taipei';

    // é…è‰²
    const C_BLUE   = '#1e88e5';
    const C_TEAL   = '#00d2a8';
    const C_YELLOW = '#ffd166';
    const C_ORANGE = '#ff8c42';
    const C_DEEPOR = '#ff7043';
    const C_RED    = '#e53935';
    const C_PURPLE = '#8e24aa';

    // UI refs
    const rootStyle = document.documentElement.style;
    const app=document.getElementById('app');
    const btnCollapse=document.getElementById('btnCollapse');
    const systemsDiv=document.getElementById('systems');

    const toggleDet=document.getElementById('toggleDet');
    const toggleEns=document.getElementById('toggleEns');
    const togglePts=document.getElementById('togglePts');
    const toggleRadii=document.getElementById('toggleRadii');

    const modeTracks=document.getElementById('modeTracks');
    const modeProb=document.getElementById('modeProb');
    const detBlack=document.getElementById('detBlack');
    const detIntensity=document.getElementById('detIntensity');

    const wsValue=document.getElementById('wsValue');
    const wsUnit=document.getElementById('wsUnit');
    const wsCalc=document.getElementById('wsCalc');
    const wsOut=document.getElementById('wsOut');

    const unitToggle=document.getElementById('unitToggle');
    const btnShare=document.getElementById('btnShare');

    const toastEl=document.getElementById('toast');
    function showToast(msg){ toastEl.textContent=msg; toastEl.style.display='block'; setTimeout(()=>toastEl.style.display='none', 1400); }

    // Online loader refs
    const dmModelSel=document.getElementById('dmModel');
    const dmCycleSel=document.getElementById('dmCycle');
    const dmStatus=document.getElementById('dmStatus');
    const btnLoadCycle=document.getElementById('btnLoadCycle');
    const btnLatest=document.getElementById('btnLatest');

    // TS chart refs
    const tsSystemSel=document.getElementById('tsSystemSel');
    const tsModeDet=document.getElementById('tsModeDet');
    const tsModeEns=document.getElementById('tsModeEns');
    let tsChart=null;

    // æ­·å²æ“ä½œ
    const historyLogEl=document.getElementById('historyLog');
    function logOp(msg){
      const t = new Date().toLocaleString('zh-TW',{hour12:false});
      historyLogEl.textContent += `[${t}] ${msg}\n`;
      historyLogEl.scrollTop = historyLogEl.scrollHeight;
    }

    // App state
    const systemLayers=new Map(); // key -> {group, det:[], ens:[], color, visible:true, label}
    let allRows=[]; let heatLayer=null;
    let showTracks=true; let allDetVisible=true, allEnsVisible=true, showPts=true, showRadii=true;
    let detUseBlack=true;

    // ====== Helpers ======
    function toMsFromKt(kt){ return kt*KT_TO_MS; }
    function toKmhFromKt(kt){ return kt*KT_TO_KMH; }

    function toUTCDate(s){
      if(!s) return new Date(NaN);
      const t = String(s).trim();
      if (/[zZ]$/.test(t) || /[+\-]\d{2}:?\d{2}$/.test(t)) return new Date(t);
      if (t.includes('T')) return new Date(t + 'Z');
      return new Date(t.replace(' ','T') + 'Z');
    }
    function fmtTaiwan(sUTC){
      const d = toUTCDate(sUTC);
      return d.toLocaleString('zh-TW', { timeZone: tz, hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' });
    }
    function hashColor(key){let h=0;for(let i=0;i<key.length;i++){h=(h*31+key.charCodeAt(i))>>>0;}return `hsl(${h%360} 90% 55%)`; }
    function offsetLatLon(lat, lon, bearingDeg, distKm){
      const rad=Math.PI/180, deg=180/Math.PI;
      const dByR=distKm/6371.0, Ï†1=lat*rad, Î»1=lon*rad, Î¸=bearingDeg*rad;
      const Ï†2=Math.asin(Math.sin(Ï†1)*Math.cos(dByR)+Math.cos(Ï†1)*Math.sin(dByR)*Math.cos(Î¸));
      const Î»2=Î»1+Math.atan2(Math.sin(Î¸)*Math.sin(dByR)*Math.cos(Ï†1),Math.cos(dByR)-Math.sin(Ï†1)*Math.sin(Ï†2));
      return [Ï†2*deg, ((Î»2*deg+540)%360)-180];
    }
    function mergedRingOutline(center, rNE, rSE, rSW, rNW, stepDeg=3){
      const arr=[]; for(let ang=0; ang<=360; ang+=stepDeg){
        let r=0;
        if(ang>=0 && ang<90) r = rNE||0;
        else if(ang>=90 && ang<180) r = rSE||0;
        else if(ang>=180 && ang<270) r = rSW||0;
        else r = rNW||0;
        arr.push(offsetLatLon(center[0], center[1], ang, r));
      }
      return arr;
    }
    function traverse(layer, fn){
      if(layer && layer.eachLayer){ layer.eachLayer(l=>traverse(l, fn)); }
      if(layer) fn(layer);
    }

    // ====== Color & Classification ======
    function colorByKT6(kt){
      if(kt==null || !isFinite(kt)) return C_BLUE;
      if(kt<34) return C_BLUE;
      if(kt<=63) return C_BLUE;     // ç†±å¸¶é¢¨æš´
      if(kt<=82) return C_TEAL;     // ä¸€ç´š
      if(kt<=95) return C_YELLOW;   // äºŒç´š
      if(kt<=113) return C_ORANGE;  // ä¸‰ç´š
      if(kt<=135) return C_RED;     // å››ç´š
      return C_PURPLE;              // äº”ç´š
    }
    function colorByKMH8_fromKT(kt){
      if(kt==null || !isFinite(kt)) return C_BLUE;
      if(kt<34)  return C_BLUE;    // <63
      if(kt<64)  return C_TEAL;    // 63â€“117
      if(kt<83)  return C_YELLOW;  // 118â€“152
      if(kt<96)  return C_ORANGE;  // 153â€“176
      if(kt<111) return C_DEEPOR;  // 178â€“209
      if(kt<130) return C_RED;     // 210â€“247
      if(kt<157) return '#d50000'; // 248â€“289
      return C_PURPLE;             // â‰¥291
    }
    function colorByMS4(ms){
      if(ms==null || !isFinite(ms)) return C_BLUE;
      if(ms<=17.1) return C_BLUE;      // ç†±å¸¶æ€§ä½æ°£å£“
      if(ms<=32.6) return C_TEAL;      // è¼•åº¦
      if(ms<=50.9) return C_ORANGE;    // ä¸­åº¦ï¼ˆé»ƒæ©˜ï¼‰
      return C_RED;                    // å¼·çƒˆ
    }
    function classifyKT(kt){
      if(kt==null || !isFinite(kt)) return 'â€”';
      if(kt<34) return 'æ“¾å‹•/ç†±å¸¶æ€§ä½æ°£å£“ï¼ˆ<34 ktï¼‰';
      if(kt<=63) return 'ç†±å¸¶é¢¨æš´ï¼ˆ34â€“63 ktï¼‰';
      if(kt<=82) return 'ä¸€ç´šé¢±é¢¨ï¼ˆ64â€“82 ktï¼‰';
      if(kt<=95) return 'äºŒç´šé¢±é¢¨ï¼ˆ83â€“95 ktï¼‰';
      if(kt<=113) return 'ä¸‰ç´šé¢±é¢¨ï¼ˆ96â€“113 ktï¼‰';
      if(kt<=135) return 'å››ç´šé¢±é¢¨ï¼ˆ114â€“135 ktï¼‰';
      return 'äº”ç´šé¢±é¢¨ï¼ˆâ‰¥136 ktï¼‰';
    }
    function classifyMS(ms){
      if(ms==null || !isFinite(ms)) return 'â€”';
      if(ms<=17.1) return 'ç†±å¸¶æ€§ä½æ°£å£“ï¼ˆâ‰¤17.1 m/sï¼‰';
      if(ms<=32.6) return 'è¼•åº¦é¢±é¢¨ï¼ˆ17.2â€“32.6 m/sï¼‰';
      if(ms<=50.9) return 'ä¸­åº¦é¢±é¢¨ï¼ˆ32.7â€“50.9 m/sï¼‰';
      return 'å¼·çƒˆé¢±é¢¨ï¼ˆâ‰¥51 m/sï¼‰';
    }
    function colorDynamic(kt){
      if(preferredUnit==='ms'){
        const ms = (kt!=null && isFinite(kt)) ? toMsFromKt(kt) : null;
        return colorByMS4(ms);
      } else if(preferredUnit==='kmh'){
        return colorByKMH8_fromKT(kt);
      } else {
        return colorByKT6(kt);
      }
    }
    function unitValueFromKt(kt){
      if(kt==null || !isFinite(kt)) return null;
      if(preferredUnit==='ms') return toMsFromKt(kt);
      if(preferredUnit==='kmh') return toKmhFromKt(kt);
      return kt;
    }
    function unitLabel(){ return preferredUnit==='ms'?'m/s':(preferredUnit==='kmh'?'km/h':'kt'); }

    // ====== Legend ======
    function updateLegend(){
      document.getElementById('unitToggle').textContent = 'å–®ä½ï¼š' + preferredUnit;
      const el = document.getElementById('legendText');
      if(preferredUnit==='ms'){
        el.innerHTML = `å¼·åº¦ï¼ˆ<b>m/s</b> å››ç´šï¼‰ï¼š
          <span class="item"><span class="dot" style="background:${C_BLUE}"></span>ç†±å¸¶æ€§ä½æ°£å£“</span>
          <span class="item"><span class="dot" style="background:${C_TEAL}"></span>è¼•åº¦é¢±é¢¨</span>
          <span class="item"><span class="dot" style="background:${C_ORANGE}"></span>ä¸­åº¦é¢±é¢¨</span>
          <span class="item"><span class="dot" style="background:${C_RED}"></span>å¼·çƒˆé¢±é¢¨</span>`;
      } else if(preferredUnit==='kmh'){
        el.innerHTML = `å¼·åº¦ï¼ˆ<b>km/h</b> å…«ç´šï¼‰ï¼š
          <span class="item"><span class="dot" style="background:${C_BLUE}"></span>&lt;63</span>
          <span class="item"><span class="dot" style="background:${C_TEAL}"></span>63â€“117</span>
          <span class="item"><span class="dot" style="background:${C_YELLOW}"></span>118â€“152</span>
          <span class="item"><span class="dot" style="background:${C_ORANGE}"></span>153â€“176</span>
          <span class="item"><span class="dot" style="background:${C_DEEPOR}"></span>178â€“209</span>
          <span class="item"><span class="dot" style="background:${C_RED}"></span>210â€“247</span>
          <span class="item"><span class="dot" style="background:#d50000"></span>248â€“289</span>
          <span class="item"><span class="dot" style="background:${C_PURPLE}"></span>â‰¥291</span>`;
      } else {
        el.innerHTML = `å¼·åº¦ï¼ˆ<b>kt</b> å…­ç´šï¼‰ï¼š
          <span class="item"><span class="dot" style="background:${C_BLUE}"></span>ç†±å¸¶é¢¨æš´</span>
          <span class="item"><span class="dot" style="background:${C_TEAL}"></span>ä¸€ç´š</span>
          <span class="item"><span class="dot" style="background:${C_YELLOW}"></span>äºŒç´š</span>
          <span class="item"><span class="dot" style="background:${C_ORANGE}"></span>ä¸‰ç´š</span>
          <span class="item"><span class="dot" style="background:${C_RED}"></span>å››ç´š</span>
          <span class="item"><span class="dot" style="background:${C_PURPLE}"></span>äº”ç´š</span>`;
      }
    }
    function cycleUnit(){
      preferredUnit = (preferredUnit==='kt') ? 'ms' : (preferredUnit==='ms' ? 'kmh' : 'kt');
      updateLegend();
      recolorAll();
      buildTsChart();
      updateHashNow();
      logOp(`å–®ä½åˆ‡æ›ç‚ºï¼š${preferredUnit}`);
    }

    // ====== Map ======
    const baseDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {attribution:'Â© Carto', maxZoom: 18});
    const baseOSM  = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution:'Â© OpenStreetMap', maxZoom: 18});
    const baseSat  = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {attribution:'Â© Esri', maxZoom: 18});
    const basemaps = {"Carto Dark":baseDark, "OSM":baseOSM, "Esri è¡›æ˜Ÿ":baseSat};
    let currentBase = "Carto Dark";
    const map = L.map('map', { zoomControl:true, worldCopyJump:true, layers:[baseDark] }).setView([18,130], 3);
    L.control.layers(basemaps, null, {position:'topright'}).addTo(map);
    map.createPane('probPane');  map.getPane('probPane').style.zIndex  = 300;
    map.createPane('ensPane');   map.getPane('ensPane').style.zIndex   = 500;
    map.createPane('radiiPane'); map.getPane('radiiPane').style.zIndex = 700;
    map.createPane('detPane');   map.getPane('detPane').style.zIndex   = 900;
    map.on('baselayerchange', e=>{ currentBase = e.name; updateHashNow(); });

    // ====== Build tracks ======
    function buildColoredSegments(latlngs, winds, pane, isDet){
      const segs=[];
      for(let i=1;i<latlngs.length;i++){
        const w = winds[i] ?? winds[i-1] ?? null;
        const c = (isDet && detUseBlack) ? '#000000' : colorDynamic(w);
        const seg = L.polyline([latlngs[i-1], latlngs[i]], {color:c, weight:isDet?5:3, opacity:0.98, pane});
        seg.__meta = {type:'segment', isDet, wind:w};
        segs.push(seg);
      }
      return segs;
    }
    function buildRadiiGroupsDet(pts){
      const groups=[];
      pts.forEach(p=>{
        const center=[+p.lat,+p.lon];
        const r34 = mergedRingOutline(center, p.r34ne||0,p.r34se||0,p.r34sw||0,p.r34nw||0, 3);
        const r50 = mergedRingOutline(center, p.r50ne||0,p.r50se||0,p.r50sw||0,p.r50nw||0, 3);
        const r64 = mergedRingOutline(center, p.r64ne||0,p.r64se||0,p.r64sw||0,p.r64nw||0, 3);
        const fg=L.featureGroup(undefined,{pane:'radiiPane'});
        if(r34.length) fg.addLayer(L.polygon(r34, {pane:'radiiPane', color:'#FF8000', fillColor:'#FF8000', fillOpacity:0.10, weight:1.4, opacity:0.85}));
        if(r50.length) fg.addLayer(L.polygon(r50, {pane:'radiiPane', color:'#EA0000', fillColor:'#EA0000', fillOpacity:0.15, weight:1.4, opacity:0.85}));
        if(r64.length) fg.addLayer(L.polygon(r64, {pane:'radiiPane', color:'#5B00AE', fillColor:'#5B00AE', fillOpacity:0.20, weight:1.6, opacity:0.90 }));
        fg.__meta={type:'radii'};
        groups.push(fg);
      });
      return groups;
    }
    function add24hTags(detPts){
      if(!detPts.length) return [];
      const first = toUTCDate(detPts[0].valid_time);
      const tagLayers=[];
      for(let i=1;i<detPts.length;i++){
        const t = toUTCDate(detPts[i].valid_time);
        const dh = Math.round((t-first)/36e5);
        if(dh>0 && dh%24===0){
          const txt = `+${dh}h`;
          const ic = L.divIcon({ className:'tag24', html: txt, iconAnchor: [-14, 10] });
          const mk = L.marker([+detPts[i].lat, +detPts[i].lon], {icon: ic, pane:'detPane'});
          mk.__meta = {type:'tag24', isDet:true};
          tagLayers.push(mk);
        }
      }
      return tagLayers;
    }
    function addSystemControl(key, color, label){
      const name=document.createElement('div'); name.className='sys-name';
      name.innerHTML=`<span class="dot" style="background:${color}"></span>${label}`;
      const ctl=document.createElement('div'); ctl.className='toggle';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true;
      cb.addEventListener('change',()=>{ const e=systemLayers.get(key); e.visible=cb.checked; refreshVisibility(); updateHashNow(); logOp(`åˆ‡æ›ç³»çµ±å¯è¦‹ï¼š${label} â†’ ${cb.checked?'é¡¯ç¤º':'éš±è—'}`); });
      ctl.appendChild(cb);
      systemsDiv.appendChild(name); systemsDiv.appendChild(ctl);
    }
    function addTrack(key, sample, pts, color, label){
      pts.sort((a,b)=>toUTCDate(a.valid_time)-toUTCDate(b.valid_time));
      const latlngs=pts.map(p=>[+p.lat,+p.lon]);
      const winds  =pts.map(p=> p.wind!=null? +p.wind : null);
      const isDet=(String(sample)==='-1' || sample==='auto-det');
      const pane = isDet? 'detPane' : 'ensPane';

      const segs = buildColoredSegments(latlngs, winds, pane, isDet);

      const markers=[];
      pts.forEach(p=>{
        const kt = (p.wind!=null? +p.wind : null);
        const ms = (kt!=null? toMsFromKt(kt) : null);
        const kmh= (kt!=null? toKmhFromKt(kt) : null);
        const c = (isDet && detUseBlack) ? '#000000' : colorDynamic(kt);
        const m=L.circleMarker([+p.lat,+p.lon], {
          pane, radius:isDet?5:3.5, color:'#111', weight: isDet? 1.2 : 0.8, fillColor:c, fillOpacity:1.0, opacity:0.95
        });
        m.__meta = {type:'marker', isDet, wind:kt};
        const twt = fmtTaiwan(p.valid_time);
        const utc = p.valid_time;
        const pres=(p.mslp!=null&&!isNaN(p.mslp))?p.mslp.toFixed(1)+' hPa':'â€”';
        let bestLine = 'â€”';
        if(kt!=null){
          const sKt = `${kt.toFixed(0)} kt`, sMs = `${(ms).toFixed(2)} m/s`, sKmh = `${(kmh).toFixed(1)} km/h`;
          if(preferredUnit==='kt') bestLine = `<b>${sKt}</b>ï½œ${sMs}ï½œ${sKmh}`;
          if(preferredUnit==='ms') bestLine = `${sKt}ï½œ<b>${sMs}</b>ï½œ${sKmh}`;
          if(preferredUnit==='kmh') bestLine = `${sKt}ï½œ${sMs}ï½œ<b>${sKmh}</b>`;
        }
        const ktClass = (kt!=null) ? classifyKT(kt) : 'â€”';
        const msClass = (ms!=null) ? classifyMS(ms) : 'â€”';
        m.bindPopup(`<b>${label}</b> | sample: <b>${sample}</b><br>
          æ™‚é–“ï¼ˆå°ç£ï¼‰ï¼š${twt}<br>æ™‚é–“ï¼ˆUTCï¼‰ï¼š${utc}<br>
          ä½ç½®ï¼š${(+p.lat).toFixed(2)}, ${(+p.lon).toFixed(2)}<br>
          é¢¨é€Ÿï¼š${bestLine}<br>
          åˆ†ç´šï¼ˆktï¼‰ï¼š${ktClass}<br>
          åˆ†ç´šï¼ˆm/sï¼‰ï¼š${msClass}<br>
          ä¸­å¿ƒæ°£å£“ï¼š${pres}`);
        markers.push(m);
      });

      const tag24s = isDet ? add24hTags(pts) : [];
      const radiiGroups = isDet ? buildRadiiGroupsDet(pts) : [];
      const group=L.featureGroup([...segs, ...markers, ...tag24s, ...radiiGroups]);
      if(!systemLayers.has(key)) systemLayers.set(key, {group:L.featureGroup().addTo(map), det:[], ens:[], color, visible:true, label});
      const entry=systemLayers.get(key);
      entry.group.addLayer(group);
      if(isDet) entry.det.push(group); else entry.ens.push(group);
      return group;
    }
// WeatherLab æŒ‰éˆ•
    btnOpenWL.addEventListener('click', ()=>{
      window.open('https://deepmind.google.com/science/weatherlab','_blank','noopener');
      logOp('é–‹å•Ÿ WeatherLab å®˜æ–¹ç¶²ç«™');
    });
    // ====== Recolor / visibility ======
    function recolorAll(){
      systemLayers.forEach(entry=>{
        entry.group.eachLayer(g=>{
          traverse(g, (child)=>{
            if(!child || !child.__meta) return;
            if(child.__meta.type==='segment'){
              const w = child.__meta.wind;
              const isDet = child.__meta.isDet;
              const c = (isDet && detUseBlack) ? '#000000' : colorDynamic(w);
              child.setStyle({color:c, weight:isDet?5:3});
            }else if(child.__meta.type==='marker'){
              const w = child.__meta.wind;
              const isDet = child.__meta.isDet;
              const c = (isDet && detUseBlack) ? '#000000' : colorDynamic(w);
              child.setStyle({fillColor:c});
            }
          });
        });
      });
      updateLegend();
      buildTsChart(); // å–®ä½æˆ–å¯è¦‹æ€§æ”¹è®Š â†’ åŒæ­¥é‡ç¹ªåœ–è¡¨
    }
    function recolorDeterministic(){
      systemLayers.forEach(entry=>{
        entry.det.forEach(g=>{
          traverse(g, (child)=>{
            if(child && child.__meta && child.__meta.isDet){
              if(child.__meta.type==='segment'){
                const w = child.__meta.wind;
                const c = detUseBlack ? '#000000' : colorDynamic(w);
                child.setStyle({color:c, weight:5});
              } else if(child.__meta.type==='marker'){
                const w = child.__meta.wind;
                const c = detUseBlack ? '#000000' : colorDynamic(w);
                child.setStyle({fillColor:c});
              }
            }
          });
        });
      });
      buildTsChart();
    }
    function refreshVisibility(){
      if(showTracks){
        if(heatLayer){ map.removeLayer(heatLayer); heatLayer=null; }
        systemLayers.forEach(entry=>{
          entry.group.eachLayer(g=>map.removeLayer(g));
          if(!entry.visible) return;
          if(allEnsVisible) entry.ens.forEach(g=>g.addTo(map));
          if(allDetVisible) entry.det.forEach(g=>g.addTo(map));
        });
        systemLayers.forEach(entry=>{
          entry.group.eachLayer(g=>{
            traverse(g, (child)=>{
              if(child && child.__meta && (child.__meta.type==='marker' || child.__meta.type==='tag24')){
                const isDetMarker = child.__meta.isDet;
                const parentOn = isDetMarker ? allDetVisible : allEnsVisible;
                if(showPts && parentOn) { child.addTo(map); } else { map.removeLayer(child); }
              } else if(child && child.__meta && child.__meta.type==='radii'){
                if(showRadii && allDetVisible) { child.addTo(map); } else { map.removeLayer(child); }
              }
            });
          });
        });
      }else{
        systemLayers.forEach(entry=>entry.group.eachLayer(g=>map.removeLayer(g)));
        rebuildHeatAllVisibleEns();
      }
      buildTsSystemOptions();
      buildTsChart();
    }

    // ====== Probabilityï¼ˆèˆ‡æ™‚é–“ç„¡é—œï¼‰ ======
    function rebuildHeatAllVisibleEns(){
      if(heatLayer){ map.removeLayer(heatLayer); heatLayer=null; }
      const pts=[];
      systemLayers.forEach((entry)=>{
        if(!entry.visible) return;
        entry.ens.forEach(group=>{
          traverse(group, (child)=>{
            if(child && child.__meta && child.__meta.type==='marker' && !child.__meta.isDet){
              const w = child.__meta.wind;
              const wt = (w!=null && !isNaN(w)) ? Math.min(1, Math.max(0, (w-20)/120)) : 0.3;
              const ll = child.getLatLng();
              pts.push([ll.lat, ll.lng, wt]);
            }
          });
        });
      });
      if(pts.length){
        heatLayer = L.heatLayer(pts, {pane:'probPane', radius: 18, blur: 24, maxZoom: 6, minOpacity: 0.22});
        heatLayer.addTo(map);
      }
      logOp(`æ©Ÿç‡åœ–é‡å»ºï¼šæ¨£æœ¬é»æ•¸ ${pts.length}`);
    }

    // ====== Auto-detï¼ˆä»£è¡¨æ€§æˆå“¡ï¼‰ ======
    const KM_PER_DEG=111.32;
    function buildAutoDet(samplesMap){
      const times=[]; const tsSet=new Set();
      samplesMap.forEach(rows=>rows.forEach(r=>{ if(r.valid_time && !tsSet.has(r.valid_time)){ tsSet.add(r.valid_time); times.push(r.valid_time);} }));
      times.sort((a,b)=>toUTCDate(a)-toUTCDate(b));
      const centroids=new Map();
      times.forEach(t=>{
        const pts=[];
        samplesMap.forEach(rows=>rows.forEach(r=>{ if(r.valid_time===t) pts.push([+r.lat,+r.lon]); }));
        if(pts.length){
          const mlat=pts.reduce((a,p)=>a+p[0],0)/pts.length;
          const mlon=pts.reduce((a,p)=>a+p[1],0)/pts.length;
          centroids.set(t,[mlat,mlon]);
        }
      });
      let bestSample=null, bestScore=Infinity;
      samplesMap.forEach((rows,sample)=>{
        let s=0,n=0;
        rows.forEach(r=>{
          const c=centroids.get(r.valid_time);
          if(c){
            const dLat=(+r.lat-c[0]), dLon=(+r.lon-c[1])*Math.cos((+r.lat)*Math.PI/180);
            const d=Math.sqrt(dLat*dLat + dLon*dLon)*KM_PER_DEG;
            s+=d*d; n++;
          }
        });
        if(n>0 && s<bestScore){ bestScore=s; bestSample=sample; }
      });
      if(bestSample==null) return null;
      return { sample: bestSample, rows: samplesMap.get(bestSample) };
    }

    // ====== Import & render ======
    function nnum(v){ const x=Number(v); return isFinite(x)?x:null; }
    function pick(obj, keys){ for(const k of keys){ if(obj[k]!=null && obj[k]!=='' && obj[k]!=='NaN') return obj[k]; } return null; }
    function normalizeRow(r, sourceName){
      const time = pick(r, ['valid_time','Valid_Time','valid time','time','datetime','forecast_time','forecast valid','valid_time_utc','Valid Time']);
      const lat  = pick(r, ['lat','latitude','Lat','LAT']);
      const lon  = pick(r, ['lon','longitude','Lon','LON','long']);
      const id   = pick(r, ['track_id','Track_ID','id','system','storm_id','stormid']);
      const sample = pick(r, ['sample','Sample','member','ens_member','ensemble_member']);
      const wind = pick(r, ['maximum_sustained_wind_speed_knots','max_wind','wind','Wind','Vmax','vmax_kt','Vmax_kt']);
      const mslp = pick(r, ['minimum_sea_level_pressure_hpa','mslp','pressure','MSLP','Pmin']);
      const r34ne = pick(r, ['radius_34_knot_winds_ne_km','r34ne','r34_ne_km','r34NE']);
      const r34se = pick(r, ['radius_34_knot_winds_se_km','r34se','r34_se_km','r34SE']);
      const r34sw = pick(r, ['radius_34_knot_winds_sw_km','r34sw','r34_sw_km','r34SW']);
      const r34nw = pick(r, ['radius_34_knot_winds_nw_km','r34nw','r34_nw_km','r34NW']);
      const r50ne = pick(r, ['radius_50_knot_winds_ne_km','r50ne']); const r50se = pick(r, ['radius_50_knot_winds_se_km','r50se']);
      const r50sw = pick(r, ['radius_50_knot_winds_sw_km','r50sw']); const r50nw = pick(r, ['radius_50_knot_winds_nw_km','r50nw']);
      const r64ne = pick(r, ['radius_64_knot_winds_ne_km','r64ne']); const r64se = pick(r, ['radius_64_knot_winds_se_km','r64se']);
      const r64sw = pick(r, ['radius_64_knot_winds_sw_km','r64sw']); const r64nw = pick(r, ['radius_64_knot_winds_nw_km','r64nw']);
      if(time==null || lat==null || lon==null) return null;
      return {
        source: sourceName, track_id: String(id ?? 'UNKNOWN').trim(), sample: (sample!=null ? sample : -1),
        valid_time: String(time).trim(),
        lat: nnum(lat), lon: nnum(lon),
        wind: (wind!=null ? nnum(wind) : null),
        mslp: (mslp!=null ? nnum(mslp) : null),
        r34ne: nnum(r34ne), r34se: nnum(r34se), r34sw: nnum(r34sw), r34nw: nnum(r34nw),
        r50ne: nnum(r50ne), r50se: nnum(r50se), r50sw: nnum(r50sw), r50nw: nnum(r50nw),
        r64ne: nnum(r64ne), r64se: nnum(r64se), r64sw: nnum(r64sw), r64nw: nnum(r64nw),
      };
    }
    function parseFiles(files){
      const rowsAll=[]; let filesDone=0;
      files.forEach(file=>{
        const reader=new FileReader();
        reader.onload=(ev)=>{
          try{
            let raw=ev.target.result;
            if(raw.charCodeAt(0)===0xFEFF){ raw = raw.slice(1); }
            const idx=raw.indexOf('# BEGIN DATA');
            const text=idx>=0 ? raw.slice(idx+'# BEGIN DATA'.length) : raw;
            const parsed=Papa.parse(text, {header:true, skipEmptyLines:true, dynamicTyping:false});
            const cleaned = parsed.data.map(obj=>normalizeRow(obj, file.name)).filter(x=>x && isFinite(x.lat) && isFinite(x.lon));
            rowsAll.push(...cleaned);
            filesDone++;
            if(filesDone===files.length){ renderAll(rowsAll); logOp(`æœ¬åœ°åŒ¯å…¥å®Œæˆï¼šæª”æ¡ˆ ${files.length}ã€é»ä½ ${rowsAll.length}`); }
          }catch(e){
            alert('åŒ¯å…¥éŒ¯èª¤ï¼š'+(e.message||e));
            logOp('åŒ¯å…¥éŒ¯èª¤ï¼š'+(e.message||e));
          }
        };
        reader.readAsText(file);
      });
    }
    function renderAll(rows){
      // Reset
      systemsDiv.innerHTML='';
      systemLayers.forEach(e=>map.removeLayer(e.group)); systemLayers.clear();
      if(heatLayer){ map.removeLayer(heatLayer); heatLayer=null; }
      allRows = rows.slice();

      // group by system -> sample
      const bySys=new Map();
      rows.forEach(r=>{
        const key=`${r.source} | ${r.track_id}`;
        if(!bySys.has(key)) bySys.set(key, new Map());
        const m=bySys.get(key);
        const sKey=String(r.sample);
        if(!m.has(sKey)) m.set(sKey, []);
        m.get(sKey).push(r);
      });

      const bounds=L.latLngBounds(); let has=false;
      bySys.forEach((samples, key)=>{
        const [source, track] = key.split(' | ');
        const color=hashColor(key);
        const label=`${track} (${source})`;

        // ensemble
        samples.forEach((pts, s)=>{
          if(String(s)==='-1') return;
          const g=addTrack(key, s, pts.slice(), color, label);
          try{ bounds.extend(g.getBounds()); has=true; }catch{}
        });
        // deterministic (provided or auto-det)
        if(samples.has('-1')){
          const g=addTrack(key, -1, samples.get('-1').slice(), color, label);
          try{ bounds.extend(g.getBounds()); has=true; }catch{}
        }else{
          const rep = buildAutoDet(samples);
          if(rep){
            const g=addTrack(key, 'auto-det', rep.rows.slice(), color, label);
            try{ bounds.extend(g.getBounds()); has=true; }catch{}
          }
        }
        addSystemControl(key, color, `${track} | ${source}`);
      });

      refreshVisibility();
      if(has && bounds.isValid()){ map.fitBounds(bounds.pad(0.2)); } else { map.setView([18,130], 3); }

      buildTsSystemOptions();
      buildTsChart();
      logOp(`é‡ç¹ªåœ°åœ–å®Œæˆï¼šç³»çµ± ${systemLayers.size}`);
    }

    // ====== æ™‚é–“ Ã— å¼·åº¦åœ– ======
    function gatherRowsForChart(mode, sysKey){
      const out=[];
      const entry = systemLayers.get(sysKey);
      if(!entry) return out;

      if(mode==='det'){
        entry.det.forEach(group=>{
          traverse(group, (child)=>{
            if(child && child.__meta && child.__meta.type==='marker' && child.__meta.isDet){
              const ll=child.getLatLng();
              const kt=child.__meta.wind;
              out.push({t: findTimeFromLatLon(sysKey, ll.lat, ll.lng) ?? '', kt});
            }
          });
        });
      }else{
        entry.ens.forEach(group=>{
          traverse(group, (child)=>{
            if(child && child.__meta && child.__meta.type==='marker' && !child.__meta.isDet){
              const ll=child.getLatLng();
              const kt=child.__meta.wind;
              out.push({t: findTimeFromLatLon(sysKey, ll.lat, ll.lng) ?? '', kt});
            }
          });
        });
      }
      out.sort((a,b)=>toUTCDate(a.t)-toUTCDate(b.t));
      return out.filter(r=>r.t && r.kt!=null && isFinite(r.kt));
    }
    function findTimeFromLatLon(sysKey, lat, lon){
      const [source, track] = sysKey.split(' | ');
      for(const r of allRows){
        if(r.source===source && r.track_id===track){
          if(Math.abs(r.lat-lat)<1e-4 && Math.abs(r.lon-lon)<1e-4){
            return r.valid_time;
          }
        }
      }
      return null;
    }
    function buildTsSystemOptions(){
      const prev = tsSystemSel.value;
      tsSystemSel.innerHTML='';
      let firstKey=null;
      systemLayers.forEach((entry,key)=>{
        if(!entry.visible) return; // åªåˆ—å‡ºå¯è¦‹ç³»çµ±
        if(!firstKey) firstKey=key;
        const opt=document.createElement('option');
        opt.value=key; opt.textContent = entry.label || key;
        tsSystemSel.appendChild(opt);
      });
      if(prev && Array.from(systemLayers.keys()).includes(prev) && systemLayers.get(prev)?.visible){
        tsSystemSel.value = prev;
      }else if(firstKey){
        tsSystemSel.value = firstKey;
      }
    }
    function buildTsChart(){
      const canvas = document.getElementById('tsChart');
      if(!canvas){ logOp('æ‰¾ä¸åˆ° tsChart ç•«å¸ƒ'); return; }

      const keys = Array.from(systemLayers.keys()).filter(k=>systemLayers.get(k)?.visible);
      const key = tsSystemSel.value || keys[0];
      if(!key){
        if(tsChart){ tsChart.destroy(); tsChart=null; }
        logOp('æ™‚é–“Ã—å¼·åº¦ï¼šç„¡å¯è¦‹ç³»çµ±å¯ç¹ªè£½'); return;
      }

      const mode = (tsModeDet.dataset.active==='true') ? 'det' : 'ensAll';
      const rows = gatherRowsForChart(mode, key);
      if(!rows.length){
        if(tsChart){ tsChart.destroy(); tsChart=null; }
        logOp(`æ™‚é–“Ã—å¼·åº¦ï¼š${key}ï¼ˆ${mode==='det'?'æ±ºå®šæ€§':'æ‰€æœ‰ç³»é›†'}ï¼‰ç„¡è³‡æ–™`);
        return;
      }

      const labels = rows.map(r=> fmtTaiwan(r.t));
      const kts    = rows.map(r=> r.kt);
      const values = rows.map(r=> unitValueFromKt(r.kt));

      const safeIdx = (i)=> Math.max(0, Math.min(i ?? 0, kts.length-1));
      const ptColor = (ctx)=> colorDynamic(kts[safeIdx(ctx.dataIndex)]);

      const data = {
        labels,
        datasets: [{
          label: (mode==='det'?'æ±ºå®šæ€§':'ç³»é›†ï¼ˆNï¼‰'),
          data: values,
          fill: false,
          borderColor: '#9aa7c0', // ç·šå›ºå®šè‰²ï¼ˆéœ€æ±‚ï¼‰
          borderWidth: 2,
          pointRadius: 3.5,
          pointHoverRadius: 5,
          pointBackgroundColor: ptColor,
          pointBorderColor: '#111',
          tension: 0.25
        }]
      };

      const cfg = {
        type: 'line',
        data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: { ticks:{ color:'#cfe3ff' }, grid:{ color:'#223' }},
            y: { ticks:{ color:'#cfe3ff' }, grid:{ color:'#223' }, title:{ display:true, text: unitLabel(), color:'#cfe3ff'} }
          },
          plugins: {
            legend: { labels: { color:'#cfe3ff' } },
            tooltip: {
              callbacks: {
                label: (ctx)=>{
                  const i = safeIdx(ctx.dataIndex);
                  const kt  = kts[i];
                  const ms  = (kt!=null)? toMsFromKt(kt).toFixed(2) : 'â€”';
                  const kmh = (kt!=null)? (kt*1.852).toFixed(1) : 'â€”';
                  const grade = (preferredUnit==='ms') ? classifyMS(kt!=null?toMsFromKt(kt):null) : classifyKT(kt);
                  const val = (typeof ctx.raw==='number') ? ctx.raw.toFixed(2) : ctx.raw;
                  return ` ${val} ${unitLabel()}ï½œ${kt??'â€”'} ktï½œ${ms} m/sï½œ${kmh} km/hï½œ${grade}`;
                }
              }
            }
          }
        }
      };

      try{
        if(tsChart){ tsChart.destroy(); }
        tsChart = new Chart(canvas, cfg);
        logOp(`æ™‚é–“Ã—å¼·åº¦åœ–é‡ç¹ªï¼š${key}ï¼ˆ${mode==='det'?'æ±ºå®šæ€§':'æ‰€æœ‰ç³»é›†'}ï¼‰ï¼Œæ¨£æœ¬ ${values.length}`);
      }catch(err){
        logOp('æ™‚é–“Ã—å¼·åº¦åœ–ç¹ªè£½å¤±æ•—ï¼š'+ (err && err.message ? err.message : err));
        console.error(err);
      }
    }

    // ====== åˆ†äº«ï¼ˆç‹€æ…‹ï¼‰ ======
    function serializeState(){
      const c = map.getCenter(), z = map.getZoom();
      const sysVis = {}; systemLayers.forEach((e,k)=>{ sysVis[k]=!!e.visible; });
      return {
        u: preferredUnit, b: currentBase, c: [ +c.lat.toFixed(4), +c.lng.toFixed(4) ], z,
        md: showTracks ? 0 : 1, det: +allDetVisible, ens: +allEnsVisible, pts: +showPts, rad: +showRadii, dm: +detUseBlack,
        sv: sysVis
      };
    }
    function encodeHash(obj){ return btoa(encodeURIComponent(JSON.stringify(obj))); }
    function decodeHash(h){ try{ return JSON.parse(decodeURIComponent(atob(h))); }catch(e){ return null; } }
    function updateHashNow(){ location.hash = 's=' + encodeHash(serializeState()); }
    btnShare.addEventListener('click', async ()=>{
      updateHashNow();
      const url = location.href;
      try{ await navigator.clipboard.writeText(url); showToast('å·²è¤‡è£½é€£çµï¼'); }
      catch{ showToast('ç„¡æ³•è‡ªå‹•è¤‡è£½ï¼Œè«‹æ‰‹å‹•è¤‡è£½ç¶²å€'); }
      logOp('ç”¢ç”Ÿåˆ†äº«é€£çµ');
    });

    // ====== Converter ======
    function round(n, d){ const p=Math.pow(10,d); return Math.round(n*p)/p; }
    function updateWsOut(){
      const v = parseFloat(wsValue.value);
      const u = wsUnit.value;
      if(isNaN(v)){ wsOut.innerHTML='<span class="muted">çµæœï¼š</span>â€”'; return; }
      let kt, ms, kmh;
      if(u==='kt'){ kt=v; ms=kt*KT_TO_MS; kmh=kt*KT_TO_KMH; }
      else if(u==='ms'){ ms=v; kt=ms/KT_TO_MS; kmh=kt*KT_TO_KMH; }
      else { kmh=v; kt=kmh/KT_TO_KMH; ms=kt*KT_TO_MS; }
      wsOut.innerHTML = `<span class="muted">çµæœï¼š</span>${round(kt,2)} kt ï½œ ${round(ms,2)} m/s ï½œ ${round(kmh,1)} km/h`;
      logOp(`é¢¨é€Ÿæ›ç®—ï¼š${v} ${u} â†’ ${round(kt,2)} kt / ${round(ms,2)} m/s / ${round(kmh,1)} km/h`);
    }
    wsCalc.addEventListener('click', updateWsOut);

    // ====== Mode & toggles ======
    function setDetMode(useBlack){
      detUseBlack = useBlack;
      detBlack.dataset.active = useBlack ? 'true' : 'false';
      detIntensity.dataset.active = useBlack ? 'false' : 'true';
      recolorDeterministic();
      updateHashNow();
      logOp(`æ±ºå®šæ€§é¡è‰²ï¼š${useBlack?'é»‘ç·š':'å¼·åº¦ä¸Šè‰²'}`);
    }
    modeTracks.addEventListener('click', ()=>{ showTracks=true; modeTracks.dataset.active='true'; modeProb.dataset.active='false'; refreshVisibility(); updateHashNow(); logOp('æ¨¡å¼ï¼šè·¯ç·šåœ–'); });
    modeProb.addEventListener('click', ()=>{ showTracks=false; modeTracks.dataset.active='false'; modeProb.dataset.active='true'; refreshVisibility(); updateHashNow(); logOp('æ¨¡å¼ï¼šæ©Ÿç‡åœ–'); });
    detBlack.addEventListener('click', ()=>setDetMode(true));
    detIntensity.addEventListener('click', ()=>setDetMode(false));
    toggleDet.addEventListener('change', ()=>{ allDetVisible=toggleDet.checked; refreshVisibility(); updateHashNow(); logOp(`é¡¯ç¤ºæ±ºå®šæ€§ï¼š${allDetVisible}`); });
    toggleEns.addEventListener('change', ()=>{ allEnsVisible=toggleEns.checked; refreshVisibility(); updateHashNow(); logOp(`é¡¯ç¤ºç³»é›†ï¼š${allEnsVisible}`); });
    togglePts.addEventListener('change', ()=>{ showPts=togglePts.checked; refreshVisibility(); updateHashNow(); logOp(`é¡¯ç¤ºç¯€é»ï¼š${showPts}`); });
    toggleRadii.addEventListener('change', ()=>{ showRadii=toggleRadii.checked; refreshVisibility(); updateHashNow(); logOp(`é¡¯ç¤ºé¢¨åœˆï¼š${showRadii}`); });

    unitToggle.addEventListener('click', cycleUnit);

    // ã€Œæ±ºå®šæ€§ / æ‰€æœ‰ç³»é›†ã€æŒ‰éˆ•ä¿®æ­£ï¼ˆäº‹ä»¶ï¼‹è¦–è¦ºç‹€æ…‹åˆ‡æ›ï¼‰
    function setTsMode(isDet){
      tsModeDet.dataset.active = isDet ? 'true' : 'false';
      tsModeEns.dataset.active = isDet ? 'false' : 'true';
      buildTsChart();
      logOp(`æ™‚é–“Ã—å¼·åº¦åœ–æ¨¡å¼ï¼š${isDet?'æ±ºå®šæ€§':'æ‰€æœ‰ç³»é›†'}`);
    }
    tsModeDet.addEventListener('click', ()=> setTsMode(true));
    tsModeEns.addEventListener('click', ()=> setTsMode(false));
    tsSystemSel.addEventListener('change', ()=>{ buildTsChart(); logOp(`æ™‚é–“Ã—å¼·åº¦åœ–ç³»çµ±åˆ‡æ›ï¼š${tsSystemSel.value}`); });

    // ====== Collapse sidebarï¼ˆåŒæ­¥ legend ä½ç½®ï¼‰ ======
    btnCollapse.addEventListener('click', ()=>{
      if(app.classList.contains('collapsed')){
        app.classList.remove('collapsed');
        rootStyle.setProperty('--sidebar-w','520px');
        btnCollapse.textContent='éš±è—è³‡æ–™æ¬„';
      }else{
        app.classList.add('collapsed');
        rootStyle.setProperty('--sidebar-w','0px');
        btnCollapse.textContent='é¡¯ç¤ºè³‡æ–™æ¬„';
      }
    });

    // ====== File UI ======
    document.getElementById('csvFiles').addEventListener('change', (e)=>{
      const files=Array.from(e.target.files||[]);
      if(!files.length) return;
      parseFiles(files);
      e.target.value = "";
    });

    // ====== Online loaderï¼ˆURL è·¯å¾‘ä¾ä½ æŒ‡å®šï¼‰ ======
    const dmBase = 'https://deepmind.google.com/science/weatherlab/download/cyclones';
    function pad(n){ return String(n).padStart(2,'0'); }
    function buildDMUrl(model, dateUtc){
      const yyyy = dateUtc.getUTCFullYear();
      const MM = pad(dateUtc.getUTCMonth()+1);
      const DD = pad(dateUtc.getUTCDate());
      const HH = pad(dateUtc.getUTCHours());
      const fname = `${model}_${yyyy}_${MM}_${DD}T${HH}_00_paired.csv`;
      if(model==='GRPH'){
        return `${dmBase}/GRPH/paired/csv/${fname}`;
      }else{
        return `${dmBase}/${model}/ensemble/paired/csv/${fname}`;
      }
    }
    function nearestCycleUTC(dateUtc){
      const h = dateUtc.getUTCHours();
      const cycle = h>=18 ? 18 : h>=12 ? 12 : h>=6 ? 6 : 0;
      return new Date(Date.UTC(dateUtc.getUTCFullYear(), dateUtc.getUTCMonth(), dateUtc.getUTCDate(), cycle, 0, 0));
    }
    function makeLast48Cycles(){
      const arr=[]; let t = nearestCycleUTC(new Date());
      for(let i=0;i<8;i++){
        const d = new Date(t.getTime() - i*6*3600*1000);
        const label = d.toISOString().replace(/:\d{2}\.\d{3}Z$/,'Z').slice(0,13) + 'Z';
        arr.push({date:d, label});
      }
      return arr;
    }
    function fillCycles(){
      dmCycleSel.innerHTML='';
      makeLast48Cycles().forEach((c, idx)=>{
        const opt=document.createElement('option');
        opt.value = c.date.toISOString();
        opt.textContent = c.label;
        if(idx===0) opt.selected = true;
        dmCycleSel.appendChild(opt);
      });
    }
    async function fetchOne(model, dateUtc){
      const url = buildDMUrl(model, dateUtc);
      const res = await fetch(url, {mode:'cors'});
      if(!res.ok) throw new Error('HTTP '+res.status);
      const text = await res.text();
      return {url, text};
    }
    function showDmStatus(msg, ok=true){
      dmStatus.style.display='block';
      dmStatus.style.borderColor = ok ? '#334276' : '#8b2d2d';
      dmStatus.textContent = msg;
      logOp(`ç·šä¸Šè¼‰å…¥ï¼š${msg}`);
    }
    function resetAndRenderFromText(csvText, virtualName){
      try{
        let raw=csvText;
        if(raw.charCodeAt(0)===0xFEFF){ raw = raw.slice(1); }
        const idx=raw.indexOf('# BEGIN DATA');
        const text=idx>=0 ? raw.slice(idx+'# BEGIN DATA'.length) : raw;
        const parsed=Papa.parse(text, {header:true, skipEmptyLines:true, dynamicTyping:false});
        const cleaned = parsed.data.map(obj=>normalizeRow(obj, virtualName)).filter(x=>x && isFinite(x.lat) && isFinite(x.lon));
        renderAll(cleaned);
      }catch(e){
        showDmStatus('è³‡æ–™è§£æå¤±æ•—ï¼š'+(e.message||e), false);
      }
    }
    btnLoadCycle.addEventListener('click', async ()=>{
      const model = dmModelSel.value;
      const iso = dmCycleSel.value;
      const dateUtc = new Date(iso);
      showDmStatus('ä¸‹è¼‰ä¸­â€¦');
      try{
        const out = await fetchOne(model, dateUtc);
        showDmStatus('å·²è¼‰å…¥ï¼š'+ out.url);
        resetAndRenderFromText(out.text, `${model}_${iso}_online.csv`);
      }catch(e){
        showDmStatus('æŠ“å–å¤±æ•—ï¼ˆå¯èƒ½æœªç™¼å¸ƒæˆ– CORS é™åˆ¶ï¼‰ï¼š'+(e.message||e), false);
      }
    });
    btnLatest.addEventListener('click', async ()=>{
      const model = dmModelSel.value;
      const cycles = makeLast48Cycles();
      showDmStatus('æ¸¬è©¦æœ€è¿‘å¾ªç’°â€¦');
      for(const c of cycles){
        try{
          const out = await fetchOne(model, c.date);
          showDmStatus('å·²è¼‰å…¥ï¼š'+ out.url);
          resetAndRenderFromText(out.text, `${model}_${c.date.toISOString()}_online.csv`);
          return;
        }catch(e){}
      }
      showDmStatus('è¿‘ 48h çš†ç„¡æ³•æŠ“å–ï¼ˆå¯èƒ½æœªç™¼å¸ƒæˆ– CORS é™åˆ¶ï¼‰', false);
    });
    fillCycles();
    dmModelSel.addEventListener('change', fillCycles);

    // ====== Init ======
    function updateLegendAndLog(){ updateLegend(); logOp('ä»‹é¢åˆå§‹åŒ–å®Œæˆ'); }
    updateLegendAndLog();
  </script>
</body>
</html>
